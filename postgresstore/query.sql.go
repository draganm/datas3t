// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package postgresstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBucket = `-- name: AddBucket :exec
INSERT INTO s3_buckets (
        name,
        endpoint,
        bucket,
        access_key,
        secret_key
    )
VALUES ($1, $2, $3, $4, $5)
`

type AddBucketParams struct {
	Name      string
	Endpoint  string
	Bucket    string
	AccessKey string
	SecretKey string
}

func (q *Queries) AddBucket(ctx context.Context, arg AddBucketParams) error {
	_, err := q.db.Exec(ctx, addBucket,
		arg.Name,
		arg.Endpoint,
		arg.Bucket,
		arg.AccessKey,
		arg.SecretKey,
	)
	return err
}

const addDatarangeUpload = `-- name: AddDatarangeUpload :one
INSERT INTO datarange_uploads (datas3t_id, first_datapoint_index, number_of_datapoints, data_size)
SELECT d.id, $1, $2, $3
FROM datas3ts d
WHERE d.name = $4
RETURNING id
`

type AddDatarangeUploadParams struct {
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
	Datas3tName         string
}

func (q *Queries) AddDatarangeUpload(ctx context.Context, arg AddDatarangeUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, addDatarangeUpload,
		arg.FirstDatapointIndex,
		arg.NumberOfDatapoints,
		arg.DataSize,
		arg.Datas3tName,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addDatas3t = `-- name: AddDatas3t :exec
INSERT INTO datas3ts (name, s3_bucket_id) 
SELECT $1, id 
FROM s3_buckets 
WHERE s3_buckets.name = $2
`

type AddDatas3tParams struct {
	Datas3tName string
	BucketName  string
}

func (q *Queries) AddDatas3t(ctx context.Context, arg AddDatas3tParams) error {
	_, err := q.db.Exec(ctx, addDatas3t, arg.Datas3tName, arg.BucketName)
	return err
}

const allAccessConfigs = `-- name: AllAccessConfigs :many
SELECT DISTINCT name
FROM s3_buckets
`

func (q *Queries) AllAccessConfigs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, allAccessConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const allDatas3ts = `-- name: AllDatas3ts :many
SELECT name
FROM datas3ts
`

func (q *Queries) AllDatas3ts(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, allDatas3ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const bucketExists = `-- name: BucketExists :one
SELECT count(*) > 0
FROM s3_buckets
WHERE name = $1
`

func (q *Queries) BucketExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, bucketExists, name)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkDatarangeOverlap = `-- name: CheckDatarangeOverlap :one
SELECT count(*) > 0
FROM dataranges
WHERE datas3t_id = $1
  AND min_datapoint_key < $2
  AND max_datapoint_key >= $3
`

type CheckDatarangeOverlapParams struct {
	Datas3tID       int64
	MinDatapointKey int64
	MaxDatapointKey int64
}

func (q *Queries) CheckDatarangeOverlap(ctx context.Context, arg CheckDatarangeOverlapParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDatarangeOverlap, arg.Datas3tID, arg.MinDatapointKey, arg.MaxDatapointKey)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const checkDatarangeUploadOverlap = `-- name: CheckDatarangeUploadOverlap :one
SELECT count(*) > 0
FROM datarange_uploads
WHERE datas3t_id = $1
  AND first_datapoint_index < $2
  AND (first_datapoint_index + number_of_datapoints - 1) >= $3
`

type CheckDatarangeUploadOverlapParams struct {
	Datas3tID             int64
	FirstDatapointIndex   int64
	FirstDatapointIndex_2 int64
}

func (q *Queries) CheckDatarangeUploadOverlap(ctx context.Context, arg CheckDatarangeUploadOverlapParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDatarangeUploadOverlap, arg.Datas3tID, arg.FirstDatapointIndex, arg.FirstDatapointIndex_2)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countDatarangeUploads = `-- name: CountDatarangeUploads :one
SELECT count(*)
FROM datarange_uploads
`

func (q *Queries) CountDatarangeUploads(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDatarangeUploads)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDataranges = `-- name: CountDataranges :one
SELECT count(*)
FROM dataranges
`

func (q *Queries) CountDataranges(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDataranges)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countKeysToDelete = `-- name: CountKeysToDelete :one
SELECT count(*)
FROM keys_to_delete
`

func (q *Queries) CountKeysToDelete(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countKeysToDelete)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDatarange = `-- name: CreateDatarange :one
INSERT INTO dataranges (datas3t_id, data_object_key, index_object_key, min_datapoint_key, max_datapoint_key, size_bytes)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateDatarangeParams struct {
	Datas3tID       int64
	DataObjectKey   string
	IndexObjectKey  string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) CreateDatarange(ctx context.Context, arg CreateDatarangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDatarange,
		arg.Datas3tID,
		arg.DataObjectKey,
		arg.IndexObjectKey,
		arg.MinDatapointKey,
		arg.MaxDatapointKey,
		arg.SizeBytes,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createDatarangeUpload = `-- name: CreateDatarangeUpload :one
INSERT INTO datarange_uploads (
    datas3t_id, 
    upload_id,
    data_object_key,
    index_object_key,
    first_datapoint_index, 
    number_of_datapoints, 
    data_size
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateDatarangeUploadParams struct {
	Datas3tID           int64
	UploadID            string
	DataObjectKey       string
	IndexObjectKey      string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
}

func (q *Queries) CreateDatarangeUpload(ctx context.Context, arg CreateDatarangeUploadParams) (int64, error) {
	row := q.db.QueryRow(ctx, createDatarangeUpload,
		arg.Datas3tID,
		arg.UploadID,
		arg.DataObjectKey,
		arg.IndexObjectKey,
		arg.FirstDatapointIndex,
		arg.NumberOfDatapoints,
		arg.DataSize,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const datas3tExists = `-- name: Datas3tExists :one
SELECT count(*) > 0
FROM datas3ts
`

func (q *Queries) Datas3tExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, datas3tExists)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteDatarange = `-- name: DeleteDatarange :exec
DELETE FROM dataranges WHERE id = $1
`

func (q *Queries) DeleteDatarange(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDatarange, id)
	return err
}

const deleteDatarangeUpload = `-- name: DeleteDatarangeUpload :exec
DELETE FROM datarange_uploads WHERE id = $1
`

func (q *Queries) DeleteDatarangeUpload(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteDatarangeUpload, id)
	return err
}

const getAllDatarangeUploads = `-- name: GetAllDatarangeUploads :many
SELECT id, datas3t_id, upload_id, first_datapoint_index, number_of_datapoints, data_size
FROM datarange_uploads
`

type GetAllDatarangeUploadsRow struct {
	ID                  int64
	Datas3tID           int64
	UploadID            string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
}

func (q *Queries) GetAllDatarangeUploads(ctx context.Context) ([]GetAllDatarangeUploadsRow, error) {
	rows, err := q.db.Query(ctx, getAllDatarangeUploads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDatarangeUploadsRow
	for rows.Next() {
		var i GetAllDatarangeUploadsRow
		if err := rows.Scan(
			&i.ID,
			&i.Datas3tID,
			&i.UploadID,
			&i.FirstDatapointIndex,
			&i.NumberOfDatapoints,
			&i.DataSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDataranges = `-- name: GetAllDataranges :many
SELECT id, datas3t_id, min_datapoint_key, max_datapoint_key, size_bytes
FROM dataranges
`

type GetAllDatarangesRow struct {
	ID              int64
	Datas3tID       int64
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetAllDataranges(ctx context.Context) ([]GetAllDatarangesRow, error) {
	rows, err := q.db.Query(ctx, getAllDataranges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDatarangesRow
	for rows.Next() {
		var i GetAllDatarangesRow
		if err := rows.Scan(
			&i.ID,
			&i.Datas3tID,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeFields = `-- name: GetDatarangeFields :many
SELECT min_datapoint_key, max_datapoint_key, size_bytes
FROM dataranges
`

type GetDatarangeFieldsRow struct {
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetDatarangeFields(ctx context.Context) ([]GetDatarangeFieldsRow, error) {
	rows, err := q.db.Query(ctx, getDatarangeFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangeFieldsRow
	for rows.Next() {
		var i GetDatarangeFieldsRow
		if err := rows.Scan(&i.MinDatapointKey, &i.MaxDatapointKey, &i.SizeBytes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeUploadIDs = `-- name: GetDatarangeUploadIDs :many
SELECT upload_id
FROM datarange_uploads
`

func (q *Queries) GetDatarangeUploadIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getDatarangeUploadIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var upload_id string
		if err := rows.Scan(&upload_id); err != nil {
			return nil, err
		}
		items = append(items, upload_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeUploadWithDetails = `-- name: GetDatarangeUploadWithDetails :one
SELECT 
    du.id, 
    du.datas3t_id, 
    du.upload_id, 
    du.first_datapoint_index, 
    du.number_of_datapoints, 
    du.data_size,
    du.data_object_key, 
    du.index_object_key,
    d.name as datas3t_name, 
    d.s3_bucket_id,
    s.endpoint, 
    s.bucket, 
    s.access_key, 
    s.secret_key
FROM datarange_uploads du
JOIN datas3ts d ON du.datas3t_id = d.id
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE du.id = $1
`

type GetDatarangeUploadWithDetailsRow struct {
	ID                  int64
	Datas3tID           int64
	UploadID            string
	FirstDatapointIndex int64
	NumberOfDatapoints  int64
	DataSize            int64
	DataObjectKey       string
	IndexObjectKey      string
	Datas3tName         string
	S3BucketID          int64
	Endpoint            string
	Bucket              string
	AccessKey           string
	SecretKey           string
}

func (q *Queries) GetDatarangeUploadWithDetails(ctx context.Context, id int64) (GetDatarangeUploadWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getDatarangeUploadWithDetails, id)
	var i GetDatarangeUploadWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Datas3tID,
		&i.UploadID,
		&i.FirstDatapointIndex,
		&i.NumberOfDatapoints,
		&i.DataSize,
		&i.DataObjectKey,
		&i.IndexObjectKey,
		&i.Datas3tName,
		&i.S3BucketID,
		&i.Endpoint,
		&i.Bucket,
		&i.AccessKey,
		&i.SecretKey,
	)
	return i, err
}

const getDatarangesForDatapoints = `-- name: GetDatarangesForDatapoints :many
SELECT 
    dr.id,
    dr.data_object_key,
    dr.index_object_key,
    dr.min_datapoint_key,
    dr.max_datapoint_key,
    dr.size_bytes,
    d.name as datas3t_name,
    s.endpoint,
    s.bucket,
    s.access_key,
    s.secret_key
FROM dataranges dr
JOIN datas3ts d ON dr.datas3t_id = d.id
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE d.name = $1
  AND dr.min_datapoint_key <= $2  -- datarange starts before or at our last datapoint
  AND dr.max_datapoint_key >= $3  -- datarange ends after or at our first datapoint
ORDER BY dr.min_datapoint_key
`

type GetDatarangesForDatapointsParams struct {
	Name            string
	MinDatapointKey int64
	MaxDatapointKey int64
}

type GetDatarangesForDatapointsRow struct {
	ID              int64
	DataObjectKey   string
	IndexObjectKey  string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
	Datas3tName     string
	Endpoint        string
	Bucket          string
	AccessKey       string
	SecretKey       string
}

func (q *Queries) GetDatarangesForDatapoints(ctx context.Context, arg GetDatarangesForDatapointsParams) ([]GetDatarangesForDatapointsRow, error) {
	rows, err := q.db.Query(ctx, getDatarangesForDatapoints, arg.Name, arg.MinDatapointKey, arg.MaxDatapointKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangesForDatapointsRow
	for rows.Next() {
		var i GetDatarangesForDatapointsRow
		if err := rows.Scan(
			&i.ID,
			&i.DataObjectKey,
			&i.IndexObjectKey,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
			&i.Datas3tName,
			&i.Endpoint,
			&i.Bucket,
			&i.AccessKey,
			&i.SecretKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatas3tWithBucket = `-- name: GetDatas3tWithBucket :one
SELECT d.id, d.name, d.s3_bucket_id, d.upload_counter,
       s.endpoint, s.bucket, s.access_key, s.secret_key
FROM datas3ts d
JOIN s3_buckets s ON d.s3_bucket_id = s.id
WHERE d.name = $1
`

type GetDatas3tWithBucketRow struct {
	ID            int64
	Name          string
	S3BucketID    int64
	UploadCounter int64
	Endpoint      string
	Bucket        string
	AccessKey     string
	SecretKey     string
}

func (q *Queries) GetDatas3tWithBucket(ctx context.Context, name string) (GetDatas3tWithBucketRow, error) {
	row := q.db.QueryRow(ctx, getDatas3tWithBucket, name)
	var i GetDatas3tWithBucketRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.S3BucketID,
		&i.UploadCounter,
		&i.Endpoint,
		&i.Bucket,
		&i.AccessKey,
		&i.SecretKey,
	)
	return i, err
}

const incrementUploadCounter = `-- name: IncrementUploadCounter :one
UPDATE datas3ts 
SET upload_counter = upload_counter + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING upload_counter
`

func (q *Queries) IncrementUploadCounter(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRow(ctx, incrementUploadCounter, id)
	var upload_counter int64
	err := row.Scan(&upload_counter)
	return upload_counter, err
}

const listAllBuckets = `-- name: ListAllBuckets :many
SELECT name, endpoint, bucket
FROM s3_buckets
ORDER BY name
`

type ListAllBucketsRow struct {
	Name     string
	Endpoint string
	Bucket   string
}

func (q *Queries) ListAllBuckets(ctx context.Context) ([]ListAllBucketsRow, error) {
	rows, err := q.db.Query(ctx, listAllBuckets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllBucketsRow
	for rows.Next() {
		var i ListAllBucketsRow
		if err := rows.Scan(&i.Name, &i.Endpoint, &i.Bucket); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDatas3ts = `-- name: ListDatas3ts :many
SELECT 
    d.name as datas3t_name,
    s.name as bucket_name,
    COALESCE(COUNT(dr.id), 0) as datarange_count,
    COALESCE(SUM(dr.max_datapoint_key - dr.min_datapoint_key + 1), 0) as total_datapoints,
    COALESCE(MIN(dr.min_datapoint_key), 0) as lowest_datapoint,
    COALESCE(MAX(dr.max_datapoint_key), 0) as highest_datapoint,
    COALESCE(SUM(dr.size_bytes), 0) as total_bytes
FROM datas3ts d
JOIN s3_buckets s ON d.s3_bucket_id = s.id
LEFT JOIN dataranges dr ON d.id = dr.datas3t_id
GROUP BY d.id, d.name, s.name
ORDER BY d.name
`

type ListDatas3tsRow struct {
	Datas3tName      string
	BucketName       string
	DatarangeCount   interface{}
	TotalDatapoints  interface{}
	LowestDatapoint  interface{}
	HighestDatapoint interface{}
	TotalBytes       interface{}
}

func (q *Queries) ListDatas3ts(ctx context.Context) ([]ListDatas3tsRow, error) {
	rows, err := q.db.Query(ctx, listDatas3ts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDatas3tsRow
	for rows.Next() {
		var i ListDatas3tsRow
		if err := rows.Scan(
			&i.Datas3tName,
			&i.BucketName,
			&i.DatarangeCount,
			&i.TotalDatapoints,
			&i.LowestDatapoint,
			&i.HighestDatapoint,
			&i.TotalBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const scheduleKeyForDeletion = `-- name: ScheduleKeyForDeletion :exec
INSERT INTO keys_to_delete (presigned_delete_url, delete_after)
VALUES ($1, $2)
`

type ScheduleKeyForDeletionParams struct {
	PresignedDeleteUrl string
	DeleteAfter        pgtype.Timestamp
}

func (q *Queries) ScheduleKeyForDeletion(ctx context.Context, arg ScheduleKeyForDeletionParams) error {
	_, err := q.db.Exec(ctx, scheduleKeyForDeletion, arg.PresignedDeleteUrl, arg.DeleteAfter)
	return err
}
