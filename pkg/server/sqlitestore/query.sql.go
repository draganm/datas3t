// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlitestore

import (
	"context"
)

const checkOverlappingDatapointRange = `-- name: CheckOverlappingDatapointRange :one
SELECT count(*) > 0 FROM dataranges
WHERE dataset_name = ?1
AND (
    (min_datapoint_key <= ?2 AND max_datapoint_key >= ?2) -- new range start overlaps with existing range
    OR
    (min_datapoint_key <= ?3 AND max_datapoint_key >= ?3) -- new range end overlaps with existing range
    OR
    (min_datapoint_key >= ?2 AND max_datapoint_key <= ?3) -- new range contains existing range
)
`

type CheckOverlappingDatapointRangeParams struct {
	DatasetName string
	NewMin      int64
	NewMax      int64
}

func (q *Queries) CheckOverlappingDatapointRange(ctx context.Context, arg CheckOverlappingDatapointRangeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkOverlappingDatapointRange, arg.DatasetName, arg.NewMin, arg.NewMax)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createDataset = `-- name: CreateDataset :exec
INSERT INTO datasets (name) VALUES (?)
`

func (q *Queries) CreateDataset(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createDataset, name)
	return err
}

const datasetExists = `-- name: DatasetExists :one
SELECT count(*) > 0 FROM datasets WHERE name = ?
`

func (q *Queries) DatasetExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, datasetExists, name)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const deleteDatarange = `-- name: DeleteDatarange :exec
DELETE FROM dataranges WHERE id = ?
`

func (q *Queries) DeleteDatarange(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteDatarange, id)
	return err
}

const deleteKeyToDeleteById = `-- name: DeleteKeyToDeleteById :exec
DELETE FROM keys_to_delete WHERE id = ?
`

func (q *Queries) DeleteKeyToDeleteById(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteKeyToDeleteById, id)
	return err
}

const getAllDatasets = `-- name: GetAllDatasets :many
SELECT 
    d.name as id,
    (SELECT COUNT(id) FROM dataranges WHERE dataset_name = d.name) as datarange_count,
    CAST(COALESCE((SELECT SUM(size_bytes) FROM dataranges WHERE dataset_name = d.name), 0) AS UNSIGNED BIGINT) as total_size_bytes,
    CAST(COALESCE((SELECT MIN(min_datapoint_key) FROM dataranges WHERE dataset_name = d.name), 0) AS UNSIGNED BIGINT) as min_datapoint_key,
    CAST(COALESCE((SELECT MAX(max_datapoint_key) FROM dataranges WHERE dataset_name = d.name), 0) AS UNSIGNED BIGINT) as max_datapoint_key
FROM datasets d
ORDER BY d.name
`

type GetAllDatasetsRow struct {
	ID              string
	DatarangeCount  int64
	TotalSizeBytes  int64
	MinDatapointKey int64
	MaxDatapointKey int64
}

func (q *Queries) GetAllDatasets(ctx context.Context) ([]GetAllDatasetsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllDatasets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDatasetsRow
	for rows.Next() {
		var i GetAllDatasetsRow
		if err := rows.Scan(
			&i.ID,
			&i.DatarangeCount,
			&i.TotalSizeBytes,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatapointsForDataset = `-- name: GetDatapointsForDataset :many
SELECT d.id, d.datarange_id, d.datapoint_key, d.begin_offset, d.end_offset 
FROM datapoints d
WHERE d.datarange_id IN (
    SELECT id FROM dataranges WHERE dataset_name = ?
)
ORDER BY d.datapoint_key
`

func (q *Queries) GetDatapointsForDataset(ctx context.Context, datasetName string) ([]Datapoint, error) {
	rows, err := q.db.QueryContext(ctx, getDatapointsForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datapoint
	for rows.Next() {
		var i Datapoint
		if err := rows.Scan(
			&i.ID,
			&i.DatarangeID,
			&i.DatapointKey,
			&i.BeginOffset,
			&i.EndOffset,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatapointsInRange = `-- name: GetDatapointsInRange :many
SELECT d.id, d.datarange_id, d.datapoint_key, d.begin_offset, d.end_offset 
FROM datapoints d
JOIN dataranges dr ON d.datarange_id = dr.id
WHERE dr.dataset_name = ?1
AND d.datapoint_key >= ?2
AND d.datapoint_key <= ?3
ORDER BY d.datapoint_key
`

type GetDatapointsInRangeParams struct {
	DatasetName string
	StartKey    int64
	EndKey      int64
}

func (q *Queries) GetDatapointsInRange(ctx context.Context, arg GetDatapointsInRangeParams) ([]Datapoint, error) {
	rows, err := q.db.QueryContext(ctx, getDatapointsInRange, arg.DatasetName, arg.StartKey, arg.EndKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datapoint
	for rows.Next() {
		var i Datapoint
		if err := rows.Scan(
			&i.ID,
			&i.DatarangeID,
			&i.DatapointKey,
			&i.BeginOffset,
			&i.EndOffset,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeIDsForDataset = `-- name: GetDatarangeIDsForDataset :many
SELECT id FROM dataranges WHERE dataset_name = ?
`

func (q *Queries) GetDatarangeIDsForDataset(ctx context.Context, datasetName string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getDatarangeIDsForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangesForAggregation = `-- name: GetDatarangesForAggregation :many
SELECT id, object_key, min_datapoint_key, max_datapoint_key, size_bytes 
FROM dataranges 
WHERE dataset_name = ?1
AND (
    (min_datapoint_key <= ?2 AND max_datapoint_key >= ?3)
)
ORDER BY min_datapoint_key ASC
`

type GetDatarangesForAggregationParams struct {
	DatasetName string
	EndKey      int64
	StartKey    int64
}

type GetDatarangesForAggregationRow struct {
	ID              int64
	ObjectKey       string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetDatarangesForAggregation(ctx context.Context, arg GetDatarangesForAggregationParams) ([]GetDatarangesForAggregationRow, error) {
	rows, err := q.db.QueryContext(ctx, getDatarangesForAggregation, arg.DatasetName, arg.EndKey, arg.StartKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangesForAggregationRow
	for rows.Next() {
		var i GetDatarangesForAggregationRow
		if err := rows.Scan(
			&i.ID,
			&i.ObjectKey,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangesForDataset = `-- name: GetDatarangesForDataset :many
SELECT object_key, min_datapoint_key, max_datapoint_key, size_bytes 
FROM dataranges 
WHERE dataset_name = ?
ORDER BY min_datapoint_key ASC
`

type GetDatarangesForDatasetRow struct {
	ObjectKey       string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetDatarangesForDataset(ctx context.Context, datasetName string) ([]GetDatarangesForDatasetRow, error) {
	rows, err := q.db.QueryContext(ctx, getDatarangesForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangesForDatasetRow
	for rows.Next() {
		var i GetDatarangesForDatasetRow
		if err := rows.Scan(
			&i.ObjectKey,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeysToDelete = `-- name: GetKeysToDelete :many
SELECT id, key FROM keys_to_delete 
WHERE delete_at <= datetime('now')
LIMIT 100
`

type GetKeysToDeleteRow struct {
	ID  int64
	Key string
}

func (q *Queries) GetKeysToDelete(ctx context.Context) ([]GetKeysToDeleteRow, error) {
	rows, err := q.db.QueryContext(ctx, getKeysToDelete)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeysToDeleteRow
	for rows.Next() {
		var i GetKeysToDeleteRow
		if err := rows.Scan(&i.ID, &i.Key); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsOfDataranges = `-- name: GetSectionsOfDataranges :many
SELECT 
    dr.id,
    dr.object_key,
    CAST((CASE 
        WHEN dr.min_datapoint_key < ?1 THEN 
            (SELECT d.begin_offset 
             FROM datapoints d 
             WHERE d.datarange_id = dr.id 
             AND d.datapoint_key = ?1 
             LIMIT 1)
        ELSE 
            0
    END) AS UNSIGNED BIGINT) as first_offset,
    CAST((CASE 
        WHEN dr.max_datapoint_key > ?2 THEN 
            (SELECT d.end_offset 
             FROM datapoints d 
             WHERE d.datarange_id = dr.id 
             AND d.datapoint_key <= ?2 
             ORDER BY d.datapoint_key DESC 
             LIMIT 1)
        ELSE 
            dr.size_bytes-1024
    END) AS UNSIGNED BIGINT) as last_offset,
    dr.size_bytes
FROM dataranges dr
WHERE dr.dataset_name = ?3
AND dr.min_datapoint_key <= ?2
AND dr.max_datapoint_key >= ?1
ORDER BY dr.object_key
`

type GetSectionsOfDatarangesParams struct {
	StartKey    int64
	EndKey      int64
	DatasetName string
}

type GetSectionsOfDatarangesRow struct {
	ID          int64
	ObjectKey   string
	FirstOffset int64
	LastOffset  int64
	SizeBytes   int64
}

func (q *Queries) GetSectionsOfDataranges(ctx context.Context, arg GetSectionsOfDatarangesParams) ([]GetSectionsOfDatarangesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsOfDataranges, arg.StartKey, arg.EndKey, arg.DatasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionsOfDatarangesRow
	for rows.Next() {
		var i GetSectionsOfDatarangesRow
		if err := rows.Scan(
			&i.ID,
			&i.ObjectKey,
			&i.FirstOffset,
			&i.LastOffset,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDataRange = `-- name: InsertDataRange :one
INSERT INTO dataranges (dataset_name, object_key, min_datapoint_key, max_datapoint_key, size_bytes) 
VALUES (?, ?, ?, ?, ?)
RETURNING id
`

type InsertDataRangeParams struct {
	DatasetName     string
	ObjectKey       string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) InsertDataRange(ctx context.Context, arg InsertDataRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDataRange,
		arg.DatasetName,
		arg.ObjectKey,
		arg.MinDatapointKey,
		arg.MaxDatapointKey,
		arg.SizeBytes,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDatapoint = `-- name: InsertDatapoint :exec
INSERT INTO datapoints (datarange_id, datapoint_key, begin_offset, end_offset)
VALUES (?, ?, ?, ?)
`

type InsertDatapointParams struct {
	DatarangeID  int64
	DatapointKey int64
	BeginOffset  int64
	EndOffset    int64
}

func (q *Queries) InsertDatapoint(ctx context.Context, arg InsertDatapointParams) error {
	_, err := q.db.ExecContext(ctx, insertDatapoint,
		arg.DatarangeID,
		arg.DatapointKey,
		arg.BeginOffset,
		arg.EndOffset,
	)
	return err
}

const insertKeyToDelete = `-- name: InsertKeyToDelete :exec
INSERT INTO keys_to_delete (key, delete_at)
VALUES (?, datetime('now', '+1 day'))
`

func (q *Queries) InsertKeyToDelete(ctx context.Context, key string) error {
	_, err := q.db.ExecContext(ctx, insertKeyToDelete, key)
	return err
}

const updateDatapointsDatarangeID = `-- name: UpdateDatapointsDatarangeID :exec
UPDATE datapoints 
SET datarange_id = ?1
WHERE datapoint_key >= ?2
AND datapoint_key <= ?3
AND datarange_id IN (
    SELECT id FROM dataranges 
    WHERE dataset_name = ?4
)
`

type UpdateDatapointsDatarangeIDParams struct {
	NewDatarangeID int64
	StartKey       int64
	EndKey         int64
	DatasetName    string
}

func (q *Queries) UpdateDatapointsDatarangeID(ctx context.Context, arg UpdateDatapointsDatarangeIDParams) error {
	_, err := q.db.ExecContext(ctx, updateDatapointsDatarangeID,
		arg.NewDatarangeID,
		arg.StartKey,
		arg.EndKey,
		arg.DatasetName,
	)
	return err
}
