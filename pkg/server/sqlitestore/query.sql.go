// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlitestore

import (
	"context"
)

const checkOverlappingDatapointRange = `-- name: CheckOverlappingDatapointRange :one
SELECT count(*) > 0 FROM dataranges
WHERE dataset_name = ?1
AND (
    (min_datapoint_key <= ?2 AND max_datapoint_key >= ?2) -- new range start overlaps with existing range
    OR
    (min_datapoint_key <= ?3 AND max_datapoint_key >= ?3) -- new range end overlaps with existing range
    OR
    (min_datapoint_key >= ?2 AND max_datapoint_key <= ?3) -- new range contains existing range
)
`

type CheckOverlappingDatapointRangeParams struct {
	DatasetName string
	NewMin      int64
	NewMax      int64
}

func (q *Queries) CheckOverlappingDatapointRange(ctx context.Context, arg CheckOverlappingDatapointRangeParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkOverlappingDatapointRange, arg.DatasetName, arg.NewMin, arg.NewMax)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const createDataset = `-- name: CreateDataset :exec
INSERT INTO datasets (name) VALUES (?)
`

func (q *Queries) CreateDataset(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createDataset, name)
	return err
}

const datasetExists = `-- name: DatasetExists :one
SELECT count(*) > 0 FROM datasets WHERE name = ?
`

func (q *Queries) DatasetExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, datasetExists, name)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const getDatapointsForDataset = `-- name: GetDatapointsForDataset :many
SELECT d.id, d.datarange_id, d.datapoint_key, d.begin_offset, d.end_offset 
FROM datapoints d
JOIN dataranges dr ON d.datarange_id = dr.id
WHERE dr.dataset_name = ?
ORDER BY d.datapoint_key
`

func (q *Queries) GetDatapointsForDataset(ctx context.Context, datasetName string) ([]Datapoint, error) {
	rows, err := q.db.QueryContext(ctx, getDatapointsForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Datapoint
	for rows.Next() {
		var i Datapoint
		if err := rows.Scan(
			&i.ID,
			&i.DatarangeID,
			&i.DatapointKey,
			&i.BeginOffset,
			&i.EndOffset,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeIDsForDataset = `-- name: GetDatarangeIDsForDataset :many
SELECT id FROM dataranges WHERE dataset_name = ?
`

func (q *Queries) GetDatarangeIDsForDataset(ctx context.Context, datasetName string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getDatarangeIDsForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDatarangeOffsets = `-- name: GetDatarangeOffsets :one
SELECT dr.id, dr.dataset_name, dr.object_key,
       MIN(dp.begin_offset) as min_offset,
       MAX(dp.end_offset) as max_offset
FROM dataranges dr
JOIN datapoints dp ON dp.datarange_id = dr.id
WHERE dr.id = ?
GROUP BY dr.id
`

type GetDatarangeOffsetsRow struct {
	ID          int64
	DatasetName string
	ObjectKey   string
	MinOffset   interface{}
	MaxOffset   interface{}
}

func (q *Queries) GetDatarangeOffsets(ctx context.Context, id int64) (GetDatarangeOffsetsRow, error) {
	row := q.db.QueryRowContext(ctx, getDatarangeOffsets, id)
	var i GetDatarangeOffsetsRow
	err := row.Scan(
		&i.ID,
		&i.DatasetName,
		&i.ObjectKey,
		&i.MinOffset,
		&i.MaxOffset,
	)
	return i, err
}

const getDatarangesForDataset = `-- name: GetDatarangesForDataset :many
SELECT object_key, min_datapoint_key, max_datapoint_key, size_bytes 
FROM dataranges 
WHERE dataset_name = ?
ORDER BY min_datapoint_key ASC
`

type GetDatarangesForDatasetRow struct {
	ObjectKey       string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) GetDatarangesForDataset(ctx context.Context, datasetName string) ([]GetDatarangesForDatasetRow, error) {
	rows, err := q.db.QueryContext(ctx, getDatarangesForDataset, datasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDatarangesForDatasetRow
	for rows.Next() {
		var i GetDatarangesForDatasetRow
		if err := rows.Scan(
			&i.ObjectKey,
			&i.MinDatapointKey,
			&i.MaxDatapointKey,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSectionsOfDataranges = `-- name: GetSectionsOfDataranges :many
SELECT 
    dr.object_key,
    MIN(CASE WHEN d.datapoint_key >= ?1 THEN d.begin_offset END) as first_offset,
    MAX(CASE WHEN d.datapoint_key <= ?2 THEN d.end_offset END) as last_offset
FROM dataranges dr
JOIN datapoints d ON d.datarange_id = dr.id
WHERE dr.dataset_name = ?3
AND d.datapoint_key <= ?2
AND EXISTS (
    SELECT 1 FROM datapoints d2 
    WHERE d2.datarange_id = dr.id 
    AND d2.datapoint_key >= ?1
)
GROUP BY dr.object_key
ORDER BY dr.object_key
`

type GetSectionsOfDatarangesParams struct {
	StartKey    int64
	EndKey      int64
	DatasetName string
}

type GetSectionsOfDatarangesRow struct {
	ObjectKey   string
	FirstOffset interface{}
	LastOffset  interface{}
}

func (q *Queries) GetSectionsOfDataranges(ctx context.Context, arg GetSectionsOfDatarangesParams) ([]GetSectionsOfDatarangesRow, error) {
	rows, err := q.db.QueryContext(ctx, getSectionsOfDataranges, arg.StartKey, arg.EndKey, arg.DatasetName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSectionsOfDatarangesRow
	for rows.Next() {
		var i GetSectionsOfDatarangesRow
		if err := rows.Scan(&i.ObjectKey, &i.FirstOffset, &i.LastOffset); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertDataRange = `-- name: InsertDataRange :one
INSERT INTO dataranges (dataset_name, object_key, min_datapoint_key, max_datapoint_key, size_bytes) 
VALUES (?, ?, ?, ?, ?)
RETURNING id
`

type InsertDataRangeParams struct {
	DatasetName     string
	ObjectKey       string
	MinDatapointKey int64
	MaxDatapointKey int64
	SizeBytes       int64
}

func (q *Queries) InsertDataRange(ctx context.Context, arg InsertDataRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertDataRange,
		arg.DatasetName,
		arg.ObjectKey,
		arg.MinDatapointKey,
		arg.MaxDatapointKey,
		arg.SizeBytes,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertDatapoint = `-- name: InsertDatapoint :exec
INSERT INTO datapoints (datarange_id, datapoint_key, begin_offset, end_offset)
VALUES (?, ?, ?, ?)
`

type InsertDatapointParams struct {
	DatarangeID  int64
	DatapointKey int64
	BeginOffset  int64
	EndOffset    int64
}

func (q *Queries) InsertDatapoint(ctx context.Context, arg InsertDatapointParams) error {
	_, err := q.db.ExecContext(ctx, insertDatapoint,
		arg.DatarangeID,
		arg.DatapointKey,
		arg.BeginOffset,
		arg.EndOffset,
	)
	return err
}
